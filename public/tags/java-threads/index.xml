<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java Threads on Hello, Friends!</title>
    <link>https://daiwei.dev/tags/java-threads/</link>
    <description>Recent content in Java Threads on Hello, Friends!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 26 Nov 2021 11:18:55 +0800</lastBuildDate><atom:link href="https://daiwei.dev/tags/java-threads/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java Threads 7: threadpool</title>
      <link>https://daiwei.dev/posts/java/thread7_javathreadpool/</link>
      <pubDate>Fri, 26 Nov 2021 11:18:55 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread7_javathreadpool/</guid>
      <description>What is the Thread Pool in Java? As the name suggests, the thread pool in Java is actually a pool of Threads. In a simple sense, it contains a group of worker threads that are waiting for the job to be granted. They are reused in the whole process.
In a Thread Pool, a group of fixed size threads is created. Whenever a task has to be granted, one of the threads is pulled out and assigned that task by the service provider, as soon as the job is completed the thread is returned back to the thread pool.</description>
    </item>
    
    <item>
      <title>Java Threads 6: Lock</title>
      <link>https://daiwei.dev/posts/java/thread6_lock/</link>
      <pubDate>Thu, 25 Nov 2021 10:10:07 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread6_lock/</guid>
      <description>1Module: java.base 2Package: java.util.concurrent.locks 3Interface Lock 4 5All Known Implementing Classes: 6ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock Lockå®ç°æä¾›äº†æ¯”ä½¿ç”¨synchronizedæ–¹æ³•å’Œè¯­å¥è·å¾—çš„æ›´å¹¿æ³›çš„é”å®šæ“ä½œã€‚å®ƒä»¬å…è®¸æ›´çµæ´»çš„ç»“æ„ï¼Œå¯èƒ½å…·æœ‰å®Œå…¨ä¸åŒçš„å±æ€§ï¼Œå¹¶ä¸”å¯èƒ½æ”¯æŒå¤šä¸ªå…³è” Conditionå¯¹è±¡ã€‚
é”æ˜¯ç”¨äºæ§åˆ¶å¤šä¸ªçº¿ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®çš„å·¥å…·ã€‚é€šå¸¸ï¼Œé”æä¾›å¯¹å…±äº«èµ„æºçš„ç‹¬å è®¿é—®ï¼šä¸€æ¬¡åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–é”ï¼Œæ‰€æœ‰å¯¹å…±äº«èµ„æºçš„è®¿é—®éƒ½éœ€è¦å…ˆè·å–é”ã€‚ä½†æ˜¯ï¼ŒæŸäº›é”å¯èƒ½å…è®¸å¹¶å‘è®¿é—®å…±äº«èµ„æºï¼Œä¾‹å¦‚ReadWriteLock.
synchronizedæ–¹æ³•æˆ–è¯­å¥çš„ä½¿ç”¨æä¾›å¯¹ä¸æ¯ä¸ªå¯¹è±¡å…³è”çš„éšå¼ç›‘è§†å™¨é”çš„è®¿é—®ï¼Œä½†å¼ºåˆ¶æ‰€æœ‰é”çš„è·å–å’Œé‡Šæ”¾ä»¥å—ç»“æ„çš„æ–¹å¼å‘ç”Ÿï¼šå½“è·å–å¤šä¸ªé”æ—¶ï¼Œå®ƒä»¬å¿…é¡»ä»¥ç›¸åçš„é¡ºåºé‡Šæ”¾ï¼Œå¹¶ä¸”æ‰€æœ‰é”å¿…é¡»åœ¨è·å¾—å®ƒä»¬çš„åŒä¸€ä¸ªè¯æ³•èŒƒå›´å†…é‡Šæ”¾ã€‚
è™½ç„¶synchronizedæ–¹æ³•å’Œè¯­å¥çš„ä½œç”¨åŸŸæœºåˆ¶ä½¿ä½¿ç”¨ç›‘è§†å™¨é”ç¼–ç¨‹å˜å¾—æ›´åŠ å®¹æ˜“ï¼Œå¹¶æœ‰åŠ©äºé¿å…è®¸å¤šæ¶‰åŠé”çš„å¸¸è§ç¼–ç¨‹é”™è¯¯ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦ä»¥æ›´çµæ´»çš„æ–¹å¼ä½¿ç”¨é”ã€‚ä¾‹å¦‚ï¼Œä¸€äº›éå†å¹¶å‘è®¿é—®æ•°æ®ç»“æ„çš„ç®—æ³•éœ€è¦ä½¿ç”¨â€œhand-over-handâ€æˆ–â€œchainlockingâ€ï¼šä½ å…ˆè·å–èŠ‚ç‚¹Açš„é”ï¼Œç„¶åèŠ‚ç‚¹Bï¼Œç„¶åé‡Šæ”¾Aï¼Œè·å–Cï¼Œç„¶åé‡Šæ”¾Bå¹¶è·å¾— D ç­‰ç­‰ã€‚æ‰€è¿°çš„å®æ–½æ–¹å¼ä¸­ Lockæ¥å£é€šè¿‡å…è®¸è·å¾—å¹¶åœ¨ä¸åŒçš„èŒƒå›´é‡Šæ”¾çš„é”ï¼Œå¹¶å…è®¸è·å¾—å¹¶ä»¥ä»»ä½•é¡ºåºé‡Šæ”¾å¤šä¸ªé”ä½¿å¾—èƒ½å¤Ÿä½¿ç”¨è¿™æ ·çš„æŠ€æœ¯ã€‚
è¿™ç§å¢åŠ çš„çµæ´»æ€§å¸¦æ¥äº†é¢å¤–çš„è´£ä»»ã€‚å—ç»“æ„é”çš„ç¼ºå¤±æ¶ˆé™¤äº†synchronized æ–¹æ³•å’Œè¯­å¥ä¸­å‘ç”Ÿçš„é”çš„è‡ªåŠ¨é‡Šæ”¾ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œåº”ä½¿ç”¨ä»¥ä¸‹ä¹ è¯­ï¼š
1 Lock l = new Lock; 2 l.lock(); 3 try { 4 // access the resource protected by this lock 5 } finally { 6 l.unlock(); 7 } å½“é”å®šå’Œè§£é”å‘ç”Ÿåœ¨ä¸åŒçš„ä½œç”¨åŸŸæ—¶ï¼Œå¿…é¡»æ³¨æ„ç¡®ä¿æŒæœ‰é”æ—¶æ‰§è¡Œçš„æ‰€æœ‰ä»£ç éƒ½å—åˆ° try-finally æˆ– try-catch çš„ä¿æŠ¤ï¼Œä»¥ç¡®ä¿åœ¨å¿…è¦æ—¶é‡Šæ”¾é”ã€‚
1package lockTest; 2 3 4import java.util.concurrent.locks.ReentrantLock; 5 6/** 7* ConcurrentThread Safety 8* The solution 1: synchronized 9* The solution 2: lock 10*/ 11public class LockTest { 12 public static void main(String[] args) { 13 Window w = new Window(); 14 15 Thread t1 = new Thread(w); 16 Thread t2 = new Thread(w); 17 Thread t3 = new Thread(w); 18 19 t1.</description>
    </item>
    
    <item>
      <title>Java Threads 5: Thread synchronized</title>
      <link>https://daiwei.dev/posts/java/thread5_synchronized/</link>
      <pubDate>Wed, 24 Nov 2021 13:16:20 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread5_synchronized/</guid>
      <description>1/** 2* çº¿ç¨‹é€šä¿¡ä¾‹å­ï¼šä¸¤ä¸ªçº¿ç¨‹äº¤æ›¿æ‰“å° integer 1-10 3* æ¶‰åŠ3ä¸ªæ–¹æ³•ï¼š 4* wait(): å½“å‰çº¿ç¨‹è¿›å…¥waitçŠ¶æ€ï¼Œå¹¶é‡Šæ”¾çº¿ç¨‹ç›‘è§†å™¨ã€‚ 5* notify(): å”¤é†’ä¸€ä¸ªå¤„äºwaitçŠ¶æ€ä¸­ä¼˜å…ˆçº§æœ€é«˜çš„çº¿ç¨‹ã€‚ 6* notifyAll(): å”¤é†’æ‰€æœ‰å¤„äºwaitçŠ¶æ€çš„çº¿ç¨‹ã€‚ 7* 8* 1. 3ä¸ªæ–¹æ³•éƒ½å¿…é¡»æ˜¯ç”¨åœ¨åŒæ­¥ä»£ç å—æˆ–è€…åŒæ­¥æ–¹æ³•ä¸­ã€‚ 9* 2. 3ä¸ªæ–¹æ³•çš„è°ƒç”¨è€…å¿…é¡»æ˜¯åŒæ­¥ä»£ç å—æˆ–è€…åŒæ­¥æ–¹æ³•ä¸­çš„åŒæ­¥ç›‘è§†å™¨ã€‚ 10* 3. 3ä¸ªæ–¹æ³•æ˜¯å®šä¹‰åœ¨java.Lang.Objectç±»ä¸­ï¼Œ å¹¶ä¸æ˜¯ thread ç±»ä¸­ã€‚ 11*/ 12public class CommunicationTest { 13 public static void main (String[] args) { 14 NumberPrinter n = new NumberPrinter(); 15 Thread t1 = new Thread(n); 16 Thread t2 = new Thread(n); 17 18 t1.start(); 19 t2.start(); 20 } 21} 22 23class NumberPrinter implements Runnable { 24 int i = 1; 25 26 @Override 27 public void run() { 28 while (true) { 29 synchronized (this) { 30 notify(); // å¿…é¡»ä½¿ç”¨åŒæ­¥ç›‘è§†å™¨thisæ¥è°ƒç”¨ï¼Œthis.</description>
    </item>
    
    <item>
      <title>Java Threads 4:Threads Safety</title>
      <link>https://daiwei.dev/posts/java/thread4_safety/</link>
      <pubDate>Tue, 23 Nov 2021 12:08:57 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread4_safety/</guid>
      <description>Unsafe threads in tickets system ä¸å®‰å…¨çº¿ç¨‹:
1public class WindowTest2 { 2 public static void main (String[] args) { 3 Window2 w = new Window2(); 4 5 Thread t1 = new Thread (w); 6 Thread t2 = new Thread (w); 7 Thread t3 = new Thread (w); 8 9 t1.setName(&amp;#34;Window_1&amp;#34;); 10 t2.setName(&amp;#34;Window_2&amp;#34;); 11 t3.setName(&amp;#34;Window_3&amp;#34;); 12 13 t1.start(); 14 t2.start(); 15 t3.start(); 16 } 17} 18 19class Window2 implements Runnable { 20 private int tickets = 100; 21 22 @Override 23 public void run() { 24 while(true) { 25 if(tickets &amp;gt; 0) { 26 try { 27 Thread.</description>
    </item>
    
    <item>
      <title>Java Threads 3: threadpool</title>
      <link>https://daiwei.dev/posts/java/thread3_threadpool/</link>
      <pubDate>Mon, 22 Nov 2021 15:57:02 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread3_threadpool/</guid>
      <description>æå‰å»ºå¥½å¤šä¸ªçº¿ç¨‹æ”¾å…¥çº¿ç¨‹æ± ä¸­ï¼Œä½¿ç”¨æ—¶ç›´æ¥è·å–ã€‚é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹ï¼Œå®ç°çº¿ç¨‹é‡å¤åˆ©ç”¨ã€‚
çº¿ç¨‹æ± ç±»ä¼¼å…¬äº¤è½¦ğŸšŒï¼Œæ¯ä¸ªäººéƒ½å¯ä»¥æŒ‰è‡ªå·±çš„éœ€é€‰æ‹©ä¹˜åä»»ä½•ä¸€è¾†å…¬äº¤è½¦ã€‚
å¥½å¤„ï¼š
 å»ºå¥½çº¿ç¨‹åˆ›å»ºæ—¶é—´ï¼Œæé«˜ç¨‹åºç›¸åº”é€Ÿåº¦ã€‚ çº¿ç¨‹å¯é‡å¤åˆ©ç”¨ï¼Œé™ä½ç³»ç»Ÿèµ„æºæ¶ˆè€—ã€‚ ä¾¿äºçº¿ç¨‹ç®¡ç†ï¼Œæé«˜ç¼–ç¨‹æ•ˆç‡ã€‚  çº¿ç¨‹æ± API:
 ExecutorService çº¿ç¨‹æ± æ¥å£ï¼Œå¸¸è§å­ç±» ThreadPoolExecutor Executor å·¥å…·ç±»ï¼Œçº¿ç¨‹æ± å·¥å‚ç±»ï¼Œç”¨äºåˆ›å»ºå¹¶è¿”å›ä¸åŒç±»å‹çš„çº¿ç¨‹ã€‚  1package threadpool; 2 3import java.util.concurrent.ExecutorService; 4import java.util.concurrent.Executors; 5import java.util.concurrent.ThreadPoolExecutor; 6import java.util.concurrent.TimeUnit; 7 8/** 9* çº¿ç¨‹åˆ›å»ºæ–¹å¼4ï¼š ThreadPool 10*/ 11public class ThreadPool { 12 public static void main(String[] args) { 13 ExecutorService service = Executors.newScheduledThreadPool(10); 14 15 //è®¾ç½®çº¿ç¨‹æ± å±æ€§ï¼Œå…ˆæŠŠExecutorService è½¬æ¢æˆ ThreadPoolExecutor 16 //ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; 17 //service1.setCorePoolSize(5); 18 //service1.setKeepAliveTime(100, TimeUnit.MILLISECONDS); 19 20 //service.submit(Callable callable);//é€‚åˆé€‚ç”¨äºCallable 21 service.</description>
    </item>
    
    <item>
      <title>Java Threads 2: Callable</title>
      <link>https://daiwei.dev/posts/java/thread2_callable/</link>
      <pubDate>Sun, 21 Nov 2021 15:39:23 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread2_callable/</guid>
      <description>1package callableTest; 2 3import java.util.concurrent.Callable; 4import java.util.concurrent.ExecutionException; 5import java.util.concurrent.FutureTask; 6 7/** 8* åˆ›å»ºçº¿ç¨‹æ–¹å¼3ï¼šå®ç° callable æ¥å£ã€‚-----JDK5.0æ–°å¢ 9*/ 10public class ThreadNew { 11 public static void main (String[] arg) { 12 NumThread num = new NumThread(); 13 14 // Futureæ¥å£å¯ä»¥å¯¹Runnable, callableçš„æ‰§è¡Œç»“æœè¿›è¡Œå–æ¶ˆï¼ŒæŸ¥è¯¢å’Œè·å–ã€‚ 15 // FutureTask åŒæ—¶å®ç°äº†Runnable &amp;amp; Futureæ¥å£ï¼Œ 16 // æ—¢å¯ä½œä¸ºçº¿ç¨‹è¢«Runnableæ‰§è¡Œï¼Œåˆå¯ä»¥ä½œä¸ºFutureå¾—åˆ°Callableçš„è¿”å›å€¼ã€‚ 17 FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(num); 18 19 new Thread(futureTask).start(); 20 21 try { 22 //get()è¿”å›å€¼å³callableå®ç°ç±»override call() è¿”å›å€¼ 23 Integer sum = futureTask.</description>
    </item>
    
    <item>
      <title>Java Threads 1: Introduction</title>
      <link>https://daiwei.dev/posts/java/thread1/</link>
      <pubDate>Sat, 20 Nov 2021 11:37:08 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java/thread1/</guid>
      <description>1Module java.base 2Package java.lang 3 4java.lang.Object 5java.lang.Thread 6 7public class Thread 8extends Object 9implements Runnable What are Threads in Java? A thread, in the context of Java, is the path followed when executing a program. All Java programs have at least one thread, known as the main thread, which is created by the Java Virtual Machine (JVM) at the programâ€™s start, when the main() method is invoked with the main thread.</description>
    </item>
    
  </channel>
</rss>
