<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello, Friends!</title>
    <link>https://daiwei.dev/</link>
    <description>Recent content on Hello, Friends!</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 17 Nov 2021 16:19:45 +0800</lastBuildDate><atom:link href="https://daiwei.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java_Roadmap</title>
      <link>https://daiwei.dev/posts/java_roadmap/</link>
      <pubDate>Wed, 17 Nov 2021 16:19:45 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java_roadmap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>git : Changes not staged for commit</title>
      <link>https://daiwei.dev/posts/git_bug1/</link>
      <pubDate>Tue, 16 Nov 2021 17:19:26 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/git_bug1/</guid>
      <description>1Changes not staged for commit: 2	modified: themes/hermit (modified content, untracked content) 3 4no changes added to commit 出现此问题是因为该路径内有文件已修改但是没被提交到本地仓库，可以尝试 cd 到子文件路径，add &amp;amp; commit, 然后返回原工作区路径，再add &amp;amp; commit一次。
1$ cd themes/hermit 2hermit $ git add . 3hermit $ git git commit -m &amp;#39;message&amp;#39; 4 5hermit $ cd ../.. 6$ git add . 7$ git git commit -m &amp;#39;message&amp;#39; </description>
    </item>
    
    <item>
      <title>fatal: Authentication failed for &#39;https://github.com/yourusername/githubtest.git/&#39; </title>
      <link>https://daiwei.dev/posts/git_authentication/</link>
      <pubDate>Mon, 15 Nov 2021 12:02:42 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/git_authentication/</guid>
      <description>fatal: Authentication failed for &amp;lsquo;https:/githubtest.git/&amp;rsquo; 这是因为github开启了Two Factor Authentication (2FA）验证，所以当你使用这些 git clone, git fetch, git pull or git push命令的时候就会需要输入你的 PAT (Personal Access Token).
在github settings 打开 Developer settings, 创建PAT, 创建完成后copy 你的PAT 再 使用之前的 git push 命令就可以输入用户名和你的PAT了（注意输入PAT,不是你的github密码）. 请参考 GitHub　Creating a personal access token.
1$ git clone https://github.com/username/repo.git 2Username: your_username 3Password: your_token </description>
    </item>
    
    <item>
      <title>env: node: No such file or directory macOS 解决方法</title>
      <link>https://daiwei.dev/posts/node_error/</link>
      <pubDate>Wed, 10 Nov 2021 12:37:00 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/node_error/</guid>
      <description>使用nmp命令时报错
1env: noder: No such file or directory 网上冲浪得到的解决方案
 uninstall and reinstall Node.js execute this command to create a link for node : sudo ln -s /usr/bin/nodejs /usr/local/bin/node  我用的方案1 重装 node.js 有效， 方案2 会报错。
1$ brew uninstall node 2$ brew update 3$ brew upgrade 4$ brew cleanup 5$ brew install node 6$ brew link --overwrite node // 如果报错可跑此命名:$ brew unlink node &amp;amp;&amp;amp; brew link node 7$ brew postinstall node 8$ node -v //能看到版本号就可以正常使用了 9 v17.</description>
    </item>
    
    <item>
      <title>git,github &amp; gitlab</title>
      <link>https://daiwei.dev/posts/git/</link>
      <pubDate>Tue, 09 Nov 2021 16:24:04 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/git/</guid>
      <description>Git 诞生于2005年，由大神 Linus Torvalds 开发的免费开源的分布式版本控制系统,可让你管理和跟踪源代码历史记录。Git 安装和维护在您的本地系统上，不需要internet联网。
github，和gitlab都是基于git开发的管理托管服务。其他 Git 存储库托管服务还有：BitBucket， SourceForge.
Github 发布于2008年，是一种基于云的git仓库托管服务。提供免费的公共仓库(代码会被所有人看到)和收费的私有仓库(代码仅自己可见)。通常用于托管开源项目。
GitLab 发布于2013年，是一个基于 Web 的DevOps生命周期工具，它提供Git 存储库管理器。和GitHub相比gitlab允许免费创建私有仓库。 另外 gitlab还可以部署到本地服务器上，让开发团队对他们的代码仓库拥有更多的控制。多用于企业或者个人的代码托管库。
 Git 常用command： git init 初始化，在本地仓库创建 .git 文档
1$ git init 2Initialized empty Git repository in /gittest/.git/ 3 4// 查看.git隐藏目录里的本地库管理文件 5$ ls -lA .git/ 6total 24 7-rw-r--r-- 1 user staff 23 9 Nov 17:38 HEAD 8-rw-r--r-- 1 user staff 137 9 Nov 17:38 config 9-rw-r--r-- 1 user staff 73 9 Nov 17:38 description 10drwxr-xr-x 13 user staff 416 9 Nov 17:38 hooks 11drwxr-xr-x 3 user staff 96 9 Nov 17:38 info 12drwxr-xr-x 4 user staff 128 9 Nov 17:38 objects 13drwxr-xr-x 4 user staff 128 9 Nov 17:38 refs git config 设置用户签名（通常只需要设置本地系统签名就足够了）</description>
    </item>
    
    <item>
      <title>Java_design</title>
      <link>https://daiwei.dev/posts/java_design/</link>
      <pubDate>Tue, 09 Nov 2021 12:11:11 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java_design/</guid>
      <description>Design Principles   SOILD
  Single Responsibility Principle (SRP) 单一职责原则
Each class should have a single purpose.
  Open/Closed Principle (OCP) 开闭原则
software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.
  Liscov Substitution Principle (LSP) 替换原则
functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
  Interface Segregation Principle (ISP) 接口隔离原则</description>
    </item>
    
    <item>
      <title>Java_oop</title>
      <link>https://daiwei.dev/posts/java_oop/</link>
      <pubDate>Tue, 09 Nov 2021 11:30:25 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java_oop/</guid>
      <description>Object-oriented programming (OOP) is a programming based on the concept of “objects” that contain data and methods. The primary purpose of object-oriented programming is to increase the flexibility and maintainability of programs. Object oriented programming brings together data and its behaviour(methods) in a single location(object) makes it easier to understand how a program works.
面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。
除了OOP, 还有面向过程(Procedure Oriented Programming)，是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程。函数式编程（Functional Programming），data更多的围绕operation， 所以添加新的方法很容易。
What is an Object 什么是对象？对象就是一组数据 data 和行为 behaviour (aka method).</description>
    </item>
    
    <item>
      <title>线程创建方式4: threadpool</title>
      <link>https://daiwei.dev/posts/java_threadpool/</link>
      <pubDate>Wed, 03 Nov 2021 15:57:02 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java_threadpool/</guid>
      <description>提前建好多个线程放入线程池中，使用时直接获取。避免频繁创建销毁线程，实现线程重复利用。
线程池类似公交车🚌，每个人都可以按自己的需选择乘坐任何一辆公交车。
好处：
 建好线程创建时间，提高程序相应速度。 线程可重复利用，降低系统资源消耗。 便于线程管理，提高编程效率。  线程池API:
 ExecutorService 线程池接口，常见子类 ThreadPoolExecutor Executor 工具类，线程池工厂类，用于创建并返回不同类型的线程。  1package threadpool; 2 3import java.util.concurrent.ExecutorService; 4import java.util.concurrent.Executors; 5import java.util.concurrent.ThreadPoolExecutor; 6import java.util.concurrent.TimeUnit; 7 8/** 9* 线程创建方式4： ThreadPool 10*/ 11public class ThreadPool { 12 public static void main(String[] args) { 13 ExecutorService service = Executors.newScheduledThreadPool(10); 14 15 //设置线程池属性，先把ExecutorService 转换成 ThreadPoolExecutor 16 //ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; 17 //service1.setCorePoolSize(5); 18 //service1.setKeepAliveTime(100, TimeUnit.MILLISECONDS); 19 20 //service.submit(Callable callable);//适合适用于Callable 21 service.</description>
    </item>
    
    <item>
      <title>创建线程的方式3: Callable</title>
      <link>https://daiwei.dev/posts/java_callable/</link>
      <pubDate>Wed, 03 Nov 2021 15:39:23 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/java_callable/</guid>
      <description>1package callableTest; 2 3import java.util.concurrent.Callable; 4import java.util.concurrent.ExecutionException; 5import java.util.concurrent.FutureTask; 6 7/** 8* 创建线程方式3：实现 callable 接口。-----JDK5.0新增 9*/ 10public class ThreadNew { 11 public static void main (String[] arg) { 12 NumThread num = new NumThread(); 13 14 // Future接口可以对Runnable, callable的执行结果进行取消，查询和获取。 15 // FutureTask 同时实现了Runnable &amp;amp; Future接口， 16 // 既可作为线程被Runnable执行，又可以作为Future得到Callable的返回值。 17 FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(num); 18 19 new Thread(futureTask).start(); 20 21 try { 22 //get()返回值即callable实现类override call() 返回值 23 Integer sum = futureTask.</description>
    </item>
    
    <item>
      <title>Thread Communication</title>
      <link>https://daiwei.dev/posts/thread_communication/</link>
      <pubDate>Wed, 03 Nov 2021 13:16:20 +0800</pubDate>
      
      <guid>https://daiwei.dev/posts/thread_communication/</guid>
      <description>1/** 2* 线程通信例子：两个线程交替打印 integer 1-10 3* 涉及3个方法： 4* wait(): 当前线程进入wait状态，并释放线程监视器。 5* notify(): 唤醒一个处于wait状态中优先级最高的线程。 6* notifyAll(): 唤醒所有处于wait状态的线程。 7* 8* 1. 3个方法都必须是用在同步代码块或者同步方法中。 9* 2. 3个方法的调用者必须是同步代码块或者同步方法中的同步监视器。 10* 3. 3个方法是定义在java.Lang.Object类中， 并不是 thread 类中。 11*/ 12public class CommunicationTest { 13 public static void main (String[] args) { 14 NumberPrinter n = new NumberPrinter(); 15 Thread t1 = new Thread(n); 16 Thread t2 = new Thread(n); 17 18 t1.start(); 19 t2.start(); 20 } 21} 22 23class NumberPrinter implements Runnable { 24 int i = 1; 25 26 @Override 27 public void run() { 28 while (true) { 29 synchronized (this) { 30 notify(); // 必须使用同步监视器this来调用，this.</description>
    </item>
    
  </channel>
</rss>
